// Bun Snapshot v1, https://goo.gl/fbAQLP

exports[`stringSlice 1`] = `
"#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <stdalign.h>
#include "wasmapi.h"


typedef struct WASM_Foo WASM_Foo;

struct WASM_Foo {
    WASM_String single;
    WASM_ConstString constSingle;
    WASM_ConstString multi[2];
    WASM_ConstString* singlePtr;
    WASM_ConstString* multiPtr;
    WASM_StringSlice slice;
    WASM_ConstStringSlice constSlice;
};

size_t __attribute__((used)) WASM_Foo_align() {
    return alignof(WASM_Foo);
}

size_t __attribute__((used)) WASM_Foo_size() {
    return sizeof(WASM_Foo);
}

size_t __attribute__((used)) WASM_Foo_single_align() {
    return alignof(WASM_String);
}

size_t __attribute__((used)) WASM_Foo_single_offset() {
    return offsetof(WASM_Foo, single);
}

size_t __attribute__((used)) WASM_Foo_single_size() {
    return sizeof(WASM_String);
}

size_t __attribute__((used)) WASM_Foo_constSingle_align() {
    return alignof(WASM_ConstString);
}

size_t __attribute__((used)) WASM_Foo_constSingle_offset() {
    return offsetof(WASM_Foo, constSingle);
}

size_t __attribute__((used)) WASM_Foo_constSingle_size() {
    return sizeof(WASM_ConstString);
}

size_t __attribute__((used)) WASM_Foo_multi_align() {
    return alignof(WASM_ConstString[2]);
}

size_t __attribute__((used)) WASM_Foo_multi_offset() {
    return offsetof(WASM_Foo, multi);
}

size_t __attribute__((used)) WASM_Foo_multi_size() {
    return sizeof(WASM_ConstString[2]);
}

size_t __attribute__((used)) WASM_Foo_singlePtr_align() {
    return alignof(WASM_ConstString*);
}

size_t __attribute__((used)) WASM_Foo_singlePtr_offset() {
    return offsetof(WASM_Foo, singlePtr);
}

size_t __attribute__((used)) WASM_Foo_singlePtr_size() {
    return sizeof(WASM_ConstString*);
}

size_t __attribute__((used)) WASM_Foo_multiPtr_align() {
    return alignof(WASM_ConstString*);
}

size_t __attribute__((used)) WASM_Foo_multiPtr_offset() {
    return offsetof(WASM_Foo, multiPtr);
}

size_t __attribute__((used)) WASM_Foo_multiPtr_size() {
    return sizeof(WASM_ConstString*);
}

size_t __attribute__((used)) WASM_Foo_slice_align() {
    return alignof(WASM_StringSlice);
}

size_t __attribute__((used)) WASM_Foo_slice_offset() {
    return offsetof(WASM_Foo, slice);
}

size_t __attribute__((used)) WASM_Foo_slice_size() {
    return sizeof(WASM_StringSlice);
}

size_t __attribute__((used)) WASM_Foo_constSlice_align() {
    return alignof(WASM_ConstStringSlice);
}

size_t __attribute__((used)) WASM_Foo_constSlice_offset() {
    return offsetof(WASM_Foo, constSlice);
}

size_t __attribute__((used)) WASM_Foo_constSlice_size() {
    return sizeof(WASM_ConstStringSlice);
}


#ifdef __cplusplus
}
#endif
"
`;

exports[`stringSlice 2`] = `
"// @ts-ignore possibly includes unused imports
import { defType, Pointer, WasmStringSlice, type IWasmMemoryAccess, type MemorySlice, type MemoryView, type WasmTypeBase, type WasmTypeKeys } from "@thi.ng/wasm-api";
// @ts-ignore
import { __array, __instanceArray, __slice32, __primslice32 } from "@thi.ng/wasm-api/memory";

// @ts-ignore possibly unused
const __str = (mem: IWasmMemoryAccess, base: number, isConst = true) => new WasmStringSlice(mem, base, isConst);

export interface Foo extends WasmTypeBase {
\treadonly single: WasmStringSlice;
\treadonly constSingle: WasmStringSlice;
\treadonly multi: WasmStringSlice[];
\treadonly singlePtr: Pointer<WasmStringSlice>;
\treadonly multiPtr: Pointer<WasmStringSlice[]>;
\treadonly slice: WasmStringSlice[];
\treadonly constSlice: WasmStringSlice[];
}

// @ts-ignore possibly unused args
export const $Foo = defType<Foo>(4, 56, (mem, base) => {
\tlet $singlePtr: Pointer<WasmStringSlice>, $multiPtr: Pointer<WasmStringSlice[]>;
\tlet $single: WasmStringSlice, $constSingle: WasmStringSlice;
\treturn {
\t\tget single(): WasmStringSlice {
\t\t\treturn $single || ($single = __str(mem, base, false));
\t\t},
\t\tget constSingle(): WasmStringSlice {
\t\t\treturn $constSingle || ($constSingle = __str(mem, (base + 8)));
\t\t},
\t\tget multi(): WasmStringSlice[] {
\t\t\tconst addr = (base + 16);
\t\t\tconst $multi: WasmStringSlice[] = [];
\t\t\tfor(let i = 0; i < 2; i++) $multi.push(__str(mem, addr + i * 8));
\t\t\treturn $multi;
\t\t},
\t\tget singlePtr(): Pointer<WasmStringSlice> {
\t\t\treturn $singlePtr || ($singlePtr = new Pointer<WasmStringSlice>(mem, (base + 32),
\t\t\t(addr) => __str(mem, addr, true)
\t\t\t));
\t\t},
\t\tget multiPtr(): Pointer<WasmStringSlice[]> {
\t\t\treturn $multiPtr || ($multiPtr = new Pointer<WasmStringSlice[]>(mem, (base + 36),
\t\t\t(addr) => {
\t\t\t\tconst $buf: WasmStringSlice[] = [];
\t\t\t\tfor(let i = 0; i < 2; i++) $buf.push(__str(mem, addr + i * 8));
\t\t\t\treturn $buf;
\t\t\t}
\t\t\t));
\t\t},
\t\tget slice(): WasmStringSlice[] {
\t\t\tconst addr = mem.u32[(base + 40) >>> 2];
\t\t\tconst len = mem.u32[(base + 44) >>> 2];
\t\t\tconst $slice: WasmStringSlice[] = [];
\t\t\tfor(let i = 0; i < len; i++) $slice.push(__str(mem, addr + i * 8, false));
\t\t\treturn $slice;
\t\t},
\t\tget constSlice(): WasmStringSlice[] {
\t\t\tconst addr = mem.u32[(base + 48) >>> 2];
\t\t\tconst len = mem.u32[(base + 52) >>> 2];
\t\t\tconst $constSlice: WasmStringSlice[] = [];
\t\t\tfor(let i = 0; i < len; i++) $constSlice.push(__str(mem, addr + i * 8));
\t\t\treturn $constSlice;
\t\t},
\t};
});
"
`;

exports[`stringSlice 3`] = `
"const std = @import("std");
const bindgen = @import("wasm-api-bindgen");

pub const Foo = extern struct {
    single: bindgen.String,
    constSingle: bindgen.ConstString,
    multi: [2]bindgen.ConstString,
    singlePtr: *bindgen.ConstString,
    multiPtr: *[2]bindgen.ConstString,
    slice: bindgen.StringSlice,
    constSlice: bindgen.ConstStringSlice,
};

export fn Foo_align() usize {
    return @alignOf(Foo);
}

export fn Foo_size() usize {
    return @sizeOf(Foo);
}

export fn Foo_single_align() usize {
    return @alignOf(bindgen.String);
}

export fn Foo_single_offset() usize {
    return @offsetOf(Foo, "single");
}

export fn Foo_single_size() usize {
    return @sizeOf(bindgen.String);
}

export fn Foo_constSingle_align() usize {
    return @alignOf(bindgen.ConstString);
}

export fn Foo_constSingle_offset() usize {
    return @offsetOf(Foo, "constSingle");
}

export fn Foo_constSingle_size() usize {
    return @sizeOf(bindgen.ConstString);
}

export fn Foo_multi_align() usize {
    return @alignOf([2]bindgen.ConstString);
}

export fn Foo_multi_offset() usize {
    return @offsetOf(Foo, "multi");
}

export fn Foo_multi_size() usize {
    return @sizeOf([2]bindgen.ConstString);
}

export fn Foo_singlePtr_align() usize {
    return @alignOf(*bindgen.ConstString);
}

export fn Foo_singlePtr_offset() usize {
    return @offsetOf(Foo, "singlePtr");
}

export fn Foo_singlePtr_size() usize {
    return @sizeOf(*bindgen.ConstString);
}

export fn Foo_multiPtr_align() usize {
    return @alignOf(*[2]bindgen.ConstString);
}

export fn Foo_multiPtr_offset() usize {
    return @offsetOf(Foo, "multiPtr");
}

export fn Foo_multiPtr_size() usize {
    return @sizeOf(*[2]bindgen.ConstString);
}

export fn Foo_slice_align() usize {
    return @alignOf(bindgen.StringSlice);
}

export fn Foo_slice_offset() usize {
    return @offsetOf(Foo, "slice");
}

export fn Foo_slice_size() usize {
    return @sizeOf(bindgen.StringSlice);
}

export fn Foo_constSlice_align() usize {
    return @alignOf(bindgen.ConstStringSlice);
}

export fn Foo_constSlice_offset() usize {
    return @offsetOf(Foo, "constSlice");
}

export fn Foo_constSlice_size() usize {
    return @sizeOf(bindgen.ConstStringSlice);
}
"
`;

exports[`stringPtr 1`] = `
"#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <stdalign.h>
#include "wasmapi.h"


typedef struct WASM_Foo WASM_Foo;

struct WASM_Foo {
    WASM_StringPtr single;
    WASM_ConstStringPtr constSingle;
    WASM_ConstStringPtr multi[2];
    WASM_ConstStringPtr* singlePtr;
    WASM_ConstStringPtr* multiPtr;
    WASM_StringPtrSlice slice;
    WASM_ConstStringPtrSlice constSlice;
};

size_t __attribute__((used)) WASM_Foo_align() {
    return alignof(WASM_Foo);
}

size_t __attribute__((used)) WASM_Foo_size() {
    return sizeof(WASM_Foo);
}

size_t __attribute__((used)) WASM_Foo_single_align() {
    return alignof(WASM_StringPtr);
}

size_t __attribute__((used)) WASM_Foo_single_offset() {
    return offsetof(WASM_Foo, single);
}

size_t __attribute__((used)) WASM_Foo_single_size() {
    return sizeof(WASM_StringPtr);
}

size_t __attribute__((used)) WASM_Foo_constSingle_align() {
    return alignof(WASM_ConstStringPtr);
}

size_t __attribute__((used)) WASM_Foo_constSingle_offset() {
    return offsetof(WASM_Foo, constSingle);
}

size_t __attribute__((used)) WASM_Foo_constSingle_size() {
    return sizeof(WASM_ConstStringPtr);
}

size_t __attribute__((used)) WASM_Foo_multi_align() {
    return alignof(WASM_ConstStringPtr[2]);
}

size_t __attribute__((used)) WASM_Foo_multi_offset() {
    return offsetof(WASM_Foo, multi);
}

size_t __attribute__((used)) WASM_Foo_multi_size() {
    return sizeof(WASM_ConstStringPtr[2]);
}

size_t __attribute__((used)) WASM_Foo_singlePtr_align() {
    return alignof(WASM_ConstStringPtr*);
}

size_t __attribute__((used)) WASM_Foo_singlePtr_offset() {
    return offsetof(WASM_Foo, singlePtr);
}

size_t __attribute__((used)) WASM_Foo_singlePtr_size() {
    return sizeof(WASM_ConstStringPtr*);
}

size_t __attribute__((used)) WASM_Foo_multiPtr_align() {
    return alignof(WASM_ConstStringPtr*);
}

size_t __attribute__((used)) WASM_Foo_multiPtr_offset() {
    return offsetof(WASM_Foo, multiPtr);
}

size_t __attribute__((used)) WASM_Foo_multiPtr_size() {
    return sizeof(WASM_ConstStringPtr*);
}

size_t __attribute__((used)) WASM_Foo_slice_align() {
    return alignof(WASM_StringPtrSlice);
}

size_t __attribute__((used)) WASM_Foo_slice_offset() {
    return offsetof(WASM_Foo, slice);
}

size_t __attribute__((used)) WASM_Foo_slice_size() {
    return sizeof(WASM_StringPtrSlice);
}

size_t __attribute__((used)) WASM_Foo_constSlice_align() {
    return alignof(WASM_ConstStringPtrSlice);
}

size_t __attribute__((used)) WASM_Foo_constSlice_offset() {
    return offsetof(WASM_Foo, constSlice);
}

size_t __attribute__((used)) WASM_Foo_constSlice_size() {
    return sizeof(WASM_ConstStringPtrSlice);
}


#ifdef __cplusplus
}
#endif
"
`;

exports[`stringPtr 2`] = `
"// @ts-ignore possibly includes unused imports
import { defType, Pointer, WasmStringPtr, type IWasmMemoryAccess, type MemorySlice, type MemoryView, type WasmTypeBase, type WasmTypeKeys } from "@thi.ng/wasm-api";
// @ts-ignore
import { __array, __instanceArray, __slice32, __primslice32 } from "@thi.ng/wasm-api/memory";

// @ts-ignore possibly unused
const __str = (mem: IWasmMemoryAccess, base: number, isConst = true) => new WasmStringPtr(mem, base, isConst);

export interface Foo extends WasmTypeBase {
\treadonly single: WasmStringPtr;
\treadonly constSingle: WasmStringPtr;
\treadonly multi: WasmStringPtr[];
\treadonly singlePtr: Pointer<WasmStringPtr>;
\treadonly multiPtr: Pointer<WasmStringPtr[]>;
\treadonly slice: WasmStringPtr[];
\treadonly constSlice: WasmStringPtr[];
}

// @ts-ignore possibly unused args
export const $Foo = defType<Foo>(4, 56, (mem, base) => {
\tlet $singlePtr: Pointer<WasmStringPtr>, $multiPtr: Pointer<WasmStringPtr[]>;
\tlet $single: WasmStringPtr, $constSingle: WasmStringPtr;
\treturn {
\t\tget single(): WasmStringPtr {
\t\t\treturn $single || ($single = __str(mem, base, false));
\t\t},
\t\tget constSingle(): WasmStringPtr {
\t\t\treturn $constSingle || ($constSingle = __str(mem, (base + 8)));
\t\t},
\t\tget multi(): WasmStringPtr[] {
\t\t\tconst addr = (base + 16);
\t\t\tconst $multi: WasmStringPtr[] = [];
\t\t\tfor(let i = 0; i < 2; i++) $multi.push(__str(mem, addr + i * 4));
\t\t\treturn $multi;
\t\t},
\t\tget singlePtr(): Pointer<WasmStringPtr> {
\t\t\treturn $singlePtr || ($singlePtr = new Pointer<WasmStringPtr>(mem, (base + 32),
\t\t\t(addr) => __str(mem, addr, true)
\t\t\t));
\t\t},
\t\tget multiPtr(): Pointer<WasmStringPtr[]> {
\t\t\treturn $multiPtr || ($multiPtr = new Pointer<WasmStringPtr[]>(mem, (base + 36),
\t\t\t(addr) => {
\t\t\t\tconst $buf: WasmStringPtr[] = [];
\t\t\t\tfor(let i = 0; i < 2; i++) $buf.push(__str(mem, addr + i * 4));
\t\t\t\treturn $buf;
\t\t\t}
\t\t\t));
\t\t},
\t\tget slice(): WasmStringPtr[] {
\t\t\tconst addr = mem.u32[(base + 40) >>> 2];
\t\t\tconst len = mem.u32[(base + 44) >>> 2];
\t\t\tconst $slice: WasmStringPtr[] = [];
\t\t\tfor(let i = 0; i < len; i++) $slice.push(__str(mem, addr + i * 4, false));
\t\t\treturn $slice;
\t\t},
\t\tget constSlice(): WasmStringPtr[] {
\t\t\tconst addr = mem.u32[(base + 48) >>> 2];
\t\t\tconst len = mem.u32[(base + 52) >>> 2];
\t\t\tconst $constSlice: WasmStringPtr[] = [];
\t\t\tfor(let i = 0; i < len; i++) $constSlice.push(__str(mem, addr + i * 4));
\t\t\treturn $constSlice;
\t\t},
\t};
});
"
`;

exports[`stringPtr 3`] = `
"const std = @import("std");
const bindgen = @import("wasm-api-bindgen");

pub const Foo = extern struct {
    single: bindgen.StringPtr,
    constSingle: bindgen.ConstStringPtr,
    multi: [2]bindgen.ConstStringPtr,
    singlePtr: *bindgen.ConstStringPtr,
    multiPtr: *[2]bindgen.ConstStringPtr,
    slice: bindgen.StringPtrSlice,
    constSlice: bindgen.ConstStringPtrSlice,
};

export fn Foo_align() usize {
    return @alignOf(Foo);
}

export fn Foo_size() usize {
    return @sizeOf(Foo);
}

export fn Foo_single_align() usize {
    return @alignOf(bindgen.StringPtr);
}

export fn Foo_single_offset() usize {
    return @offsetOf(Foo, "single");
}

export fn Foo_single_size() usize {
    return @sizeOf(bindgen.StringPtr);
}

export fn Foo_constSingle_align() usize {
    return @alignOf(bindgen.ConstStringPtr);
}

export fn Foo_constSingle_offset() usize {
    return @offsetOf(Foo, "constSingle");
}

export fn Foo_constSingle_size() usize {
    return @sizeOf(bindgen.ConstStringPtr);
}

export fn Foo_multi_align() usize {
    return @alignOf([2]bindgen.ConstStringPtr);
}

export fn Foo_multi_offset() usize {
    return @offsetOf(Foo, "multi");
}

export fn Foo_multi_size() usize {
    return @sizeOf([2]bindgen.ConstStringPtr);
}

export fn Foo_singlePtr_align() usize {
    return @alignOf(*bindgen.ConstStringPtr);
}

export fn Foo_singlePtr_offset() usize {
    return @offsetOf(Foo, "singlePtr");
}

export fn Foo_singlePtr_size() usize {
    return @sizeOf(*bindgen.ConstStringPtr);
}

export fn Foo_multiPtr_align() usize {
    return @alignOf(*[2]bindgen.ConstStringPtr);
}

export fn Foo_multiPtr_offset() usize {
    return @offsetOf(Foo, "multiPtr");
}

export fn Foo_multiPtr_size() usize {
    return @sizeOf(*[2]bindgen.ConstStringPtr);
}

export fn Foo_slice_align() usize {
    return @alignOf(bindgen.StringPtrSlice);
}

export fn Foo_slice_offset() usize {
    return @offsetOf(Foo, "slice");
}

export fn Foo_slice_size() usize {
    return @sizeOf(bindgen.StringPtrSlice);
}

export fn Foo_constSlice_align() usize {
    return @alignOf(bindgen.ConstStringPtrSlice);
}

export fn Foo_constSlice_offset() usize {
    return @offsetOf(Foo, "constSlice");
}

export fn Foo_constSlice_size() usize {
    return @sizeOf(bindgen.ConstStringPtrSlice);
}
"
`;

exports[`union 1`] = `
"#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include "wasmapi.h"


typedef struct WASM_A WASM_A;

typedef union WASM_B WASM_B;

struct WASM_A {
    uint8_t a;
    uint8_t __pad0[3];
    uint32_t b;
    uint16_t* c;
    uint8_t __pad1[2];
    double d;
};

union WASM_B {
    WASM_A a[3];
    uint64_t b;
};


#ifdef __cplusplus
}
#endif
"
`;

exports[`union 2`] = `
"// @ts-ignore possibly includes unused imports
import { defType, Pointer, WasmStringPtr, type IWasmMemoryAccess, type MemorySlice, type MemoryView, type WasmTypeBase, type WasmTypeKeys } from "@thi.ng/wasm-api";
// @ts-ignore
import { __array, __instanceArray, __slice32, __primslice32 } from "@thi.ng/wasm-api/memory";

export interface A extends WasmTypeBase {
\t/**
\t * Zig type: \`u8\`
\t */
\ta: number;
\t/**
\t * Zig type: \`u32\`
\t */
\tb: number;
\t/**
\t * Zig type: \`*[3]u16\`
\t */
\treadonly c: Pointer<Uint16Array>;
\t/**
\t * Zig type: \`f64\`
\t */
\td: number;
}

// @ts-ignore possibly unused args
export const $A = defType<A>(8, 24, (mem, base) => {
\tlet $c: Pointer<Uint16Array>;
\treturn {
\t\tget a(): number {
\t\t\treturn mem.u8[base];
\t\t},
\t\tset a(x: number) {
\t\t\tmem.u8[base] = x;
\t\t},
\t\tget b(): number {
\t\t\treturn mem.u32[(base + 4) >>> 2];
\t\t},
\t\tset b(x: number) {
\t\t\tmem.u32[(base + 4) >>> 2] = x;
\t\t},
\t\tget c(): Pointer<Uint16Array> {
\t\t\treturn $c || ($c = new Pointer<Uint16Array>(mem, (base + 8),
\t\t\t(addr) => mem.u16.subarray(addr, addr + 3)
\t\t\t));
\t\t},
\t\tget d(): number {
\t\t\treturn mem.f64[(base + 16) >>> 3];
\t\t},
\t\tset d(x: number) {
\t\t\tmem.f64[(base + 16) >>> 3] = x;
\t\t},
\t};
});

export interface B extends WasmTypeBase {
\treadonly a: A[];
\t/**
\t * Zig type: \`u64\`
\t */
\tb: bigint;
}

// @ts-ignore possibly unused args
export const $B = defType<B>(8, 72, (mem, base) => {
\treturn {
\t\tget a(): A[] {
\t\t\treturn __array(mem, $A, base, 3);
\t\t},
\t\tget b(): bigint {
\t\t\treturn mem.u64[base >>> 3];
\t\t},
\t\tset b(x: bigint) {
\t\t\tmem.u64[base >>> 3] = x;
\t\t},
\t};
});
"
`;

exports[`union 3`] = `
"const std = @import("std");
const bindgen = @import("wasm-api-bindgen");

pub const A = extern struct {
    a: u8,
    __pad0: [3]u8,
    b: u32,
    c: *[3]u16,
    __pad1: [2]u8,
    d: f64,
};

pub const B = extern union {
    a: [3]A,
    b: u64,
};
"
`;

exports[`opaque 1`] = `
"#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include "wasmapi.h"


typedef struct WASM_A WASM_A;

struct WASM_A {
    WASM_OpaquePtr a;
    WASM_OpaquePtr* ptr;
    WASM_OpaquePtr* ptr2;
    WASM_ConstOpaquePtr* constPtr;
    WASM_OpaquePtrSlice slice;
    WASM_ConstOpaquePtrSlice constSlice;
    WASM_OpaquePtr array[3];
    WASM_ConstOpaquePtr constArray[3];
};


#ifdef __cplusplus
}
#endif
"
`;

exports[`opaque 2`] = `
"// @ts-ignore possibly includes unused imports
import { defType, Pointer, WasmStringPtr, type IWasmMemoryAccess, type MemorySlice, type MemoryView, type WasmTypeBase, type WasmTypeKeys } from "@thi.ng/wasm-api";
// @ts-ignore
import { __array, __instanceArray, __slice32, __primslice32 } from "@thi.ng/wasm-api/memory";

export interface A extends WasmTypeBase {
\t/**
\t * Zig type: \`u32\`
\t */
\ta: number;
\t/**
\t * Zig type: \`*u32\`
\t */
\treadonly ptr: Pointer<number>;
\t/**
\t * Zig type: \`*[2]u32\`
\t */
\treadonly ptr2: Pointer<Uint32Array>;
\t/**
\t * Zig type: \`*const u32\`
\t */
\treadonly constPtr: Pointer<number>;
\t/**
\t * Zig type: \`U32Slice\`
\t */
\treadonly slice: Uint32Array;
\t/**
\t * Zig type: \`ConstU32Slice\`
\t */
\treadonly constSlice: Uint32Array;
\t/**
\t * Zig type: \`[3]u32\`
\t */
\treadonly array: Uint32Array;
\t/**
\t * Zig type: \`[3]u32\`
\t */
\treadonly constArray: Uint32Array;
}

// @ts-ignore possibly unused args
export const $A = defType<A>(4, 56, (mem, base) => {
\tlet $ptr: Pointer<number>, $ptr2: Pointer<Uint32Array>, $constPtr: Pointer<number>;
\treturn {
\t\tget a(): number {
\t\t\treturn mem.u32[base >>> 2];
\t\t},
\t\tset a(x: number) {
\t\t\tmem.u32[base >>> 2] = x;
\t\t},
\t\tget ptr(): Pointer<number> {
\t\t\treturn $ptr || ($ptr = new Pointer<number>(mem, (base + 4),
\t\t\t(addr) => mem.u32[addr >>> 2]
\t\t\t));
\t\t},
\t\tget ptr2(): Pointer<Uint32Array> {
\t\t\treturn $ptr2 || ($ptr2 = new Pointer<Uint32Array>(mem, (base + 8),
\t\t\t(addr) => mem.u32.subarray(addr, addr + 2)
\t\t\t));
\t\t},
\t\tget constPtr(): Pointer<number> {
\t\t\treturn $constPtr || ($constPtr = new Pointer<number>(mem, (base + 12),
\t\t\t(addr) => mem.u32[addr >>> 2]
\t\t\t));
\t\t},
\t\tget slice(): Uint32Array {
\t\t\treturn __primslice32(mem, mem.u32, (base + 16), 2);
\t\t},
\t\tget constSlice(): Uint32Array {
\t\t\treturn __primslice32(mem, mem.u32, (base + 24), 2);
\t\t},
\t\tget array(): Uint32Array {
\t\t\tconst addr = (base + 32) >>> 2;
\t\t\treturn mem.u32.subarray(addr, addr + 3);
\t\t},
\t\tget constArray(): Uint32Array {
\t\t\tconst addr = (base + 44) >>> 2;
\t\t\treturn mem.u32.subarray(addr, addr + 3);
\t\t},
\t};
});
"
`;

exports[`opaque 3`] = `
"const std = @import("std");
const bindgen = @import("wasm-api-bindgen");

pub const A = extern struct {
    a: bindgen.OpaquePtr,
    ptr: *bindgen.OpaquePtr,
    ptr2: *[2]bindgen.OpaquePtr,
    constPtr: *bindgen.ConstOpaquePtr,
    slice: bindgen.OpaquePtrSlice,
    constSlice: bindgen.ConstOpaquePtrSlice,
    array: [3]bindgen.OpaquePtr,
    constArray: [3]bindgen.ConstOpaquePtr,
};
"
`;

exports[`enum 1`] = `
"#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include "wasmapi.h"


typedef enum WASM_A WASM_A;

typedef struct { WASM_A* ptr; size_t len; } WASM_ASlice;
typedef struct { const WASM_A* ptr; size_t len; } WASM_ConstASlice;

typedef struct WASM_B WASM_B;

enum WASM_A {
    FOO,
    BAR,
    BAZ = 10,
};

struct WASM_B {
    WASM_A single;
    WASM_A array[2];
    WASM_ASlice slice;
    WASM_A* ptr;
    WASM_A* ptr2;
};


#ifdef __cplusplus
}
#endif
"
`;

exports[`enum 2`] = `
"// @ts-ignore possibly includes unused imports
import { defType, Pointer, WasmStringPtr, type IWasmMemoryAccess, type MemorySlice, type MemoryView, type WasmTypeBase, type WasmTypeKeys } from "@thi.ng/wasm-api";
// @ts-ignore
import { __array, __instanceArray, __slice32, __primslice32 } from "@thi.ng/wasm-api/memory";

export enum A {
\tFOO,
\tBAR,
\tBAZ = 10,
}

export interface B extends WasmTypeBase {
\tsingle: A;
\treadonly array: Int32Array;
\treadonly slice: Int32Array;
\treadonly ptr: Pointer<A>;
\treadonly ptr2: Pointer<Int32Array>;
}

// @ts-ignore possibly unused args
export const $B = defType<B>(4, 28, (mem, base) => {
\tlet $ptr: Pointer<A>, $ptr2: Pointer<Int32Array>;
\treturn {
\t\tget single(): A {
\t\t\treturn mem.i32[base >>> 2];
\t\t},
\t\tset single(x: A) {
\t\t\tmem.i32[base >>> 2] = x;
\t\t},
\t\tget array(): Int32Array {
\t\t\tconst addr = (base + 4) >>> 2;
\t\t\treturn mem.i32.subarray(addr, addr + 2);
\t\t},
\t\tget slice(): Int32Array {
\t\t\treturn __primslice32(mem, mem.i32, (base + 12), 2);
\t\t},
\t\tget ptr(): Pointer<A> {
\t\t\treturn $ptr || ($ptr = new Pointer<A>(mem, (base + 20),
\t\t\t(addr) => mem.i32[addr >>> 2]
\t\t\t));
\t\t},
\t\tget ptr2(): Pointer<Int32Array> {
\t\t\treturn $ptr2 || ($ptr2 = new Pointer<Int32Array>(mem, (base + 24),
\t\t\t(addr) => mem.i32.subarray(addr, addr + 2)
\t\t\t));
\t\t},
\t};
});
"
`;

exports[`enum 3`] = `
"const std = @import("std");
const bindgen = @import("wasm-api-bindgen");

pub const ASlice = bindgen.Slice([]A, [*]A);
pub const ConstASlice = bindgen.Slice([]const A, [*]const A);

pub const A = enum(i32) {
    foo,
    bar,
    baz = 10,
};

pub const B = extern struct {
    single: A,
    array: [2]A,
    slice: ASlice,
    ptr: *A,
    ptr2: *[2]A,
};
"
`;

exports[`funcptr 1`] = `
"#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include "wasmapi.h"

typedef void (*WASM_A)(uint32_t* x, WASM_ConstStringPtr y);

typedef struct { WASM_A* ptr; size_t len; } WASM_ASlice;
typedef struct { const WASM_A* ptr; size_t len; } WASM_ConstASlice;

typedef struct WASM_B WASM_B;

struct WASM_B {
    WASM_A a;
    WASM_A* ptr;
    WASM_A* ptr2;
    WASM_A array[2];
    WASM_ASlice slice;
};


#ifdef __cplusplus
}
#endif
"
`;

exports[`funcptr 2`] = `
"// @ts-ignore possibly includes unused imports
import { defType, Pointer, WasmStringPtr, type IWasmMemoryAccess, type MemorySlice, type MemoryView, type WasmTypeBase, type WasmTypeKeys } from "@thi.ng/wasm-api";
// @ts-ignore
import { __array, __instanceArray, __slice32, __primslice32 } from "@thi.ng/wasm-api/memory";

export interface B extends WasmTypeBase {
\t/**
\t * Zig type: \`u32\`
\t */
\ta: number;
\t/**
\t * Zig type: \`*u32\`
\t */
\treadonly ptr: Pointer<number>;
\t/**
\t * Zig type: \`*[2]u32\`
\t */
\treadonly ptr2: Pointer<Uint32Array>;
\t/**
\t * Zig type: \`[2]u32\`
\t */
\treadonly array: Uint32Array;
\t/**
\t * Zig type: \`U32Slice\`
\t */
\treadonly slice: Uint32Array;
}

// @ts-ignore possibly unused args
export const $B = defType<B>(4, 28, (mem, base) => {
\tlet $ptr: Pointer<number>, $ptr2: Pointer<Uint32Array>;
\treturn {
\t\tget a(): number {
\t\t\treturn mem.u32[base >>> 2];
\t\t},
\t\tset a(x: number) {
\t\t\tmem.u32[base >>> 2] = x;
\t\t},
\t\tget ptr(): Pointer<number> {
\t\t\treturn $ptr || ($ptr = new Pointer<number>(mem, (base + 4),
\t\t\t(addr) => mem.u32[addr >>> 2]
\t\t\t));
\t\t},
\t\tget ptr2(): Pointer<Uint32Array> {
\t\t\treturn $ptr2 || ($ptr2 = new Pointer<Uint32Array>(mem, (base + 8),
\t\t\t(addr) => mem.u32.subarray(addr, addr + 2)
\t\t\t));
\t\t},
\t\tget array(): Uint32Array {
\t\t\tconst addr = (base + 12) >>> 2;
\t\t\treturn mem.u32.subarray(addr, addr + 2);
\t\t},
\t\tget slice(): Uint32Array {
\t\t\treturn __primslice32(mem, mem.u32, (base + 20), 2);
\t\t},
\t};
});
"
`;

exports[`funcptr 3`] = `
"const std = @import("std");
const bindgen = @import("wasm-api-bindgen");

pub const ASlice = bindgen.Slice([]A, [*]A);
pub const ConstASlice = bindgen.Slice([]const A, [*]const A);

pub const A = *const fn (x: *u32, y: bindgen.ConstStringPtr) callconv(.C) void;

pub const B = extern struct {
    a: A,
    ptr: *A,
    ptr2: *[2]A,
    array: [2]A,
    slice: ASlice,
};
"
`;

exports[`slices 1`] = `
"#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <stdalign.h>
#include "wasmapi.h"


typedef struct { uint8_t* ptr; size_t len; } WASM_U8Slice;
typedef struct { const uint8_t* ptr; size_t len; } WASM_ConstU8Slice;

typedef struct WASM_A WASM_A;

typedef struct { WASM_A* ptr; size_t len; } WASM_ASlice;
typedef struct { const WASM_A* ptr; size_t len; } WASM_ConstASlice;

typedef struct WASM_B WASM_B;

struct WASM_A {
    uint16_t a;
};

size_t __attribute__((used)) WASM_A_align() {
    return alignof(WASM_A);
}

size_t __attribute__((used)) WASM_A_size() {
    return sizeof(WASM_A);
}

size_t __attribute__((used)) WASM_A_a_align() {
    return alignof(uint16_t);
}

size_t __attribute__((used)) WASM_A_a_offset() {
    return offsetof(WASM_A, a);
}

size_t __attribute__((used)) WASM_A_a_size() {
    return sizeof(uint16_t);
}

struct WASM_B {
    WASM_U8Slice slice;
    WASM_ConstU8Slice constSlice;
    uint8_t* ptr;
    const uint8_t* constPtr;
    uint8_t* ptr2;
    uint8_t* ptr2sentinel;
    const uint8_t* constPtr2;
    const uint8_t* constPtr2sentinel;
    uint8_t* ptrMulti;
    uint8_t* ptrMultiSentinel;
    const uint8_t* constPtrMulti;
    const uint8_t* constPtrMultiSentinel;
    int32_t array[2];
    int32_t arraySentinel[2];
    // Hidden sentinel. Must be manually initialized to 0
    int32_t __arraySentinelSentinel;
    WASM_A aSingle;
    WASM_ASlice aSlice;
    WASM_ConstASlice constASlice;
    WASM_A* aPtr;
    WASM_A* aPtr2;
    // Multiple A's
    WASM_A* aPtrMulti;
};

size_t __attribute__((used)) WASM_B_align() {
    return alignof(WASM_B);
}

size_t __attribute__((used)) WASM_B_size() {
    return sizeof(WASM_B);
}

size_t __attribute__((used)) WASM_B_slice_align() {
    return alignof(WASM_U8Slice);
}

size_t __attribute__((used)) WASM_B_slice_offset() {
    return offsetof(WASM_B, slice);
}

size_t __attribute__((used)) WASM_B_slice_size() {
    return sizeof(WASM_U8Slice);
}

size_t __attribute__((used)) WASM_B_constSlice_align() {
    return alignof(WASM_ConstU8Slice);
}

size_t __attribute__((used)) WASM_B_constSlice_offset() {
    return offsetof(WASM_B, constSlice);
}

size_t __attribute__((used)) WASM_B_constSlice_size() {
    return sizeof(WASM_ConstU8Slice);
}

size_t __attribute__((used)) WASM_B_ptr_align() {
    return alignof(uint8_t*);
}

size_t __attribute__((used)) WASM_B_ptr_offset() {
    return offsetof(WASM_B, ptr);
}

size_t __attribute__((used)) WASM_B_ptr_size() {
    return sizeof(uint8_t*);
}

size_t __attribute__((used)) WASM_B_constPtr_align() {
    return alignof(const uint8_t*);
}

size_t __attribute__((used)) WASM_B_constPtr_offset() {
    return offsetof(WASM_B, constPtr);
}

size_t __attribute__((used)) WASM_B_constPtr_size() {
    return sizeof(const uint8_t*);
}

size_t __attribute__((used)) WASM_B_ptr2_align() {
    return alignof(uint8_t*);
}

size_t __attribute__((used)) WASM_B_ptr2_offset() {
    return offsetof(WASM_B, ptr2);
}

size_t __attribute__((used)) WASM_B_ptr2_size() {
    return sizeof(uint8_t*);
}

size_t __attribute__((used)) WASM_B_ptr2sentinel_align() {
    return alignof(uint8_t*);
}

size_t __attribute__((used)) WASM_B_ptr2sentinel_offset() {
    return offsetof(WASM_B, ptr2sentinel);
}

size_t __attribute__((used)) WASM_B_ptr2sentinel_size() {
    return sizeof(uint8_t*);
}

size_t __attribute__((used)) WASM_B_constPtr2_align() {
    return alignof(const uint8_t*);
}

size_t __attribute__((used)) WASM_B_constPtr2_offset() {
    return offsetof(WASM_B, constPtr2);
}

size_t __attribute__((used)) WASM_B_constPtr2_size() {
    return sizeof(const uint8_t*);
}

size_t __attribute__((used)) WASM_B_constPtr2sentinel_align() {
    return alignof(const uint8_t*);
}

size_t __attribute__((used)) WASM_B_constPtr2sentinel_offset() {
    return offsetof(WASM_B, constPtr2sentinel);
}

size_t __attribute__((used)) WASM_B_constPtr2sentinel_size() {
    return sizeof(const uint8_t*);
}

size_t __attribute__((used)) WASM_B_ptrMulti_align() {
    return alignof(uint8_t*);
}

size_t __attribute__((used)) WASM_B_ptrMulti_offset() {
    return offsetof(WASM_B, ptrMulti);
}

size_t __attribute__((used)) WASM_B_ptrMulti_size() {
    return sizeof(uint8_t*);
}

size_t __attribute__((used)) WASM_B_ptrMultiSentinel_align() {
    return alignof(uint8_t*);
}

size_t __attribute__((used)) WASM_B_ptrMultiSentinel_offset() {
    return offsetof(WASM_B, ptrMultiSentinel);
}

size_t __attribute__((used)) WASM_B_ptrMultiSentinel_size() {
    return sizeof(uint8_t*);
}

size_t __attribute__((used)) WASM_B_constPtrMulti_align() {
    return alignof(const uint8_t*);
}

size_t __attribute__((used)) WASM_B_constPtrMulti_offset() {
    return offsetof(WASM_B, constPtrMulti);
}

size_t __attribute__((used)) WASM_B_constPtrMulti_size() {
    return sizeof(const uint8_t*);
}

size_t __attribute__((used)) WASM_B_constPtrMultiSentinel_align() {
    return alignof(const uint8_t*);
}

size_t __attribute__((used)) WASM_B_constPtrMultiSentinel_offset() {
    return offsetof(WASM_B, constPtrMultiSentinel);
}

size_t __attribute__((used)) WASM_B_constPtrMultiSentinel_size() {
    return sizeof(const uint8_t*);
}

size_t __attribute__((used)) WASM_B_array_align() {
    return alignof(int32_t[2]);
}

size_t __attribute__((used)) WASM_B_array_offset() {
    return offsetof(WASM_B, array);
}

size_t __attribute__((used)) WASM_B_array_size() {
    return sizeof(int32_t[2]);
}

size_t __attribute__((used)) WASM_B_arraySentinel_align() {
    return alignof(int32_t[2]);
}

size_t __attribute__((used)) WASM_B_arraySentinel_offset() {
    return offsetof(WASM_B, arraySentinel);
}

size_t __attribute__((used)) WASM_B_arraySentinel_size() {
    return sizeof(int32_t[2]);
}

size_t __attribute__((used)) WASM_B_aSingle_align() {
    return alignof(WASM_A);
}

size_t __attribute__((used)) WASM_B_aSingle_offset() {
    return offsetof(WASM_B, aSingle);
}

size_t __attribute__((used)) WASM_B_aSingle_size() {
    return sizeof(WASM_A);
}

size_t __attribute__((used)) WASM_B_aSlice_align() {
    return alignof(WASM_ASlice);
}

size_t __attribute__((used)) WASM_B_aSlice_offset() {
    return offsetof(WASM_B, aSlice);
}

size_t __attribute__((used)) WASM_B_aSlice_size() {
    return sizeof(WASM_ASlice);
}

size_t __attribute__((used)) WASM_B_constASlice_align() {
    return alignof(WASM_ConstASlice);
}

size_t __attribute__((used)) WASM_B_constASlice_offset() {
    return offsetof(WASM_B, constASlice);
}

size_t __attribute__((used)) WASM_B_constASlice_size() {
    return sizeof(WASM_ConstASlice);
}

size_t __attribute__((used)) WASM_B_aPtr_align() {
    return alignof(WASM_A*);
}

size_t __attribute__((used)) WASM_B_aPtr_offset() {
    return offsetof(WASM_B, aPtr);
}

size_t __attribute__((used)) WASM_B_aPtr_size() {
    return sizeof(WASM_A*);
}

size_t __attribute__((used)) WASM_B_aPtr2_align() {
    return alignof(WASM_A*);
}

size_t __attribute__((used)) WASM_B_aPtr2_offset() {
    return offsetof(WASM_B, aPtr2);
}

size_t __attribute__((used)) WASM_B_aPtr2_size() {
    return sizeof(WASM_A*);
}

size_t __attribute__((used)) WASM_B_aPtrMulti_align() {
    return alignof(WASM_A*);
}

size_t __attribute__((used)) WASM_B_aPtrMulti_offset() {
    return offsetof(WASM_B, aPtrMulti);
}

size_t __attribute__((used)) WASM_B_aPtrMulti_size() {
    return sizeof(WASM_A*);
}


#ifdef __cplusplus
}
#endif
"
`;

exports[`slices 2`] = `
"// @ts-ignore possibly includes unused imports
import { defType, Pointer, WasmStringPtr, type IWasmMemoryAccess, type MemorySlice, type MemoryView, type WasmTypeBase, type WasmTypeKeys } from "@thi.ng/wasm-api";
// @ts-ignore
import { __array, __instanceArray, __slice32, __primslice32 } from "@thi.ng/wasm-api/memory";

export interface A extends WasmTypeBase {
\t/**
\t * Zig type: \`u16\`
\t */
\ta: number;
}

// @ts-ignore possibly unused args
export const $A = defType<A>(2, 2, (mem, base) => {
\treturn {
\t\tget a(): number {
\t\t\treturn mem.u16[base >>> 1];
\t\t},
\t\tset a(x: number) {
\t\t\tmem.u16[base >>> 1] = x;
\t\t},
\t};
});

export interface B extends WasmTypeBase {
\t/**
\t * Zig type: \`U8Slice\`
\t */
\treadonly slice: Uint8Array;
\t/**
\t * Zig type: \`ConstU8Slice\`
\t */
\treadonly constSlice: Uint8Array;
\t/**
\t * Zig type: \`*u8\`
\t */
\treadonly ptr: Pointer<number>;
\t/**
\t * Zig type: \`*const u8\`
\t */
\treadonly constPtr: Pointer<number>;
\t/**
\t * Zig type: \`*[2]u8\`
\t */
\treadonly ptr2: Pointer<Uint8Array>;
\t/**
\t * Zig type: \`*[2:0]u8\`
\t */
\treadonly ptr2sentinel: Pointer<Uint8Array>;
\t/**
\t * Zig type: \`*const [2]u8\`
\t */
\treadonly constPtr2: Pointer<Uint8Array>;
\t/**
\t * Zig type: \`*const [2:0]u8\`
\t */
\treadonly constPtr2sentinel: Pointer<Uint8Array>;
\t/**
\t * Multi pointer: \`[*]u8\`
\t * 
\t * @remarks
\t * Only the pointer's target address can be accessed
\t */
\tptrMulti: number;
\t/**
\t * Multi pointer: \`[*:255]u8\`
\t * 
\t * @remarks
\t * Only the pointer's target address can be accessed
\t */
\tptrMultiSentinel: number;
\t/**
\t * Multi pointer: \`[*]const u8\`
\t * 
\t * @remarks
\t * Only the pointer's target address can be accessed
\t */
\tconstPtrMulti: number;
\t/**
\t * Multi pointer: \`[*:255]const u8\`
\t * 
\t * @remarks
\t * Only the pointer's target address can be accessed
\t */
\tconstPtrMultiSentinel: number;
\t/**
\t * Zig type: \`[2]i32\`
\t */
\treadonly array: Int32Array;
\t/**
\t * Zig type: \`[2:0]i32\`
\t */
\treadonly arraySentinel: Int32Array;
\taSingle: A;
\treadonly aSlice: A[];
\treadonly constASlice: A[];
\treadonly aPtr: Pointer<A>;
\treadonly aPtr2: Pointer<A[]>;
\t/**
\t * Multiple A's
\t * 
\t * @remarks
\t * Multi pointer: \`[*]A\`
\t * Only the pointer's target address can be accessed
\t */
\taPtrMulti: number;
}

// @ts-ignore possibly unused args
export const $B = defType<B>(4, 108, (mem, base) => {
\tlet $ptr: Pointer<number>, $constPtr: Pointer<number>, $ptr2: Pointer<Uint8Array>, $ptr2sentinel: Pointer<Uint8Array>, $constPtr2: Pointer<Uint8Array>, $constPtr2sentinel: Pointer<Uint8Array>, $aPtr: Pointer<A>, $aPtr2: Pointer<A[]>;
\treturn {
\t\tget slice(): Uint8Array {
\t\t\treturn __primslice32(mem, mem.u8, base, 0);
\t\t},
\t\tget constSlice(): Uint8Array {
\t\t\treturn __primslice32(mem, mem.u8, (base + 8), 0);
\t\t},
\t\tget ptr(): Pointer<number> {
\t\t\treturn $ptr || ($ptr = new Pointer<number>(mem, (base + 16),
\t\t\t(addr) => mem.u8[addr >>> 0]
\t\t\t));
\t\t},
\t\tget constPtr(): Pointer<number> {
\t\t\treturn $constPtr || ($constPtr = new Pointer<number>(mem, (base + 20),
\t\t\t(addr) => mem.u8[addr >>> 0]
\t\t\t));
\t\t},
\t\tget ptr2(): Pointer<Uint8Array> {
\t\t\treturn $ptr2 || ($ptr2 = new Pointer<Uint8Array>(mem, (base + 24),
\t\t\t(addr) => mem.u8.subarray(addr, addr + 2)
\t\t\t));
\t\t},
\t\tget ptr2sentinel(): Pointer<Uint8Array> {
\t\t\treturn $ptr2sentinel || ($ptr2sentinel = new Pointer<Uint8Array>(mem, (base + 28),
\t\t\t(addr) => mem.u8.subarray(addr, addr + 2)
\t\t\t));
\t\t},
\t\tget constPtr2(): Pointer<Uint8Array> {
\t\t\treturn $constPtr2 || ($constPtr2 = new Pointer<Uint8Array>(mem, (base + 32),
\t\t\t(addr) => mem.u8.subarray(addr, addr + 2)
\t\t\t));
\t\t},
\t\tget constPtr2sentinel(): Pointer<Uint8Array> {
\t\t\treturn $constPtr2sentinel || ($constPtr2sentinel = new Pointer<Uint8Array>(mem, (base + 36),
\t\t\t(addr) => mem.u8.subarray(addr, addr + 2)
\t\t\t));
\t\t},
\t\tget ptrMulti(): number {
\t\t\treturn mem.u32[(base + 40) >>> 2];
\t\t},
\t\tset ptrMulti(x: number) {
\t\t\tmem.u32[(base + 40) >>> 2] = x;
\t\t},
\t\tget ptrMultiSentinel(): number {
\t\t\treturn mem.u32[(base + 44) >>> 2];
\t\t},
\t\tset ptrMultiSentinel(x: number) {
\t\t\tmem.u32[(base + 44) >>> 2] = x;
\t\t},
\t\tget constPtrMulti(): number {
\t\t\treturn mem.u32[(base + 48) >>> 2];
\t\t},
\t\tset constPtrMulti(x: number) {
\t\t\tmem.u32[(base + 48) >>> 2] = x;
\t\t},
\t\tget constPtrMultiSentinel(): number {
\t\t\treturn mem.u32[(base + 52) >>> 2];
\t\t},
\t\tset constPtrMultiSentinel(x: number) {
\t\t\tmem.u32[(base + 52) >>> 2] = x;
\t\t},
\t\tget array(): Int32Array {
\t\t\tconst addr = (base + 56) >>> 2;
\t\t\treturn mem.i32.subarray(addr, addr + 2);
\t\t},
\t\tget arraySentinel(): Int32Array {
\t\t\tconst addr = (base + 64) >>> 2;
\t\t\treturn mem.i32.subarray(addr, addr + 2);
\t\t},
\t\tget aSingle(): A {
\t\t\treturn $A(mem).instance((base + 76));
\t\t},
\t\tset aSingle(x: A) {
\t\t\tmem.u8.set(x.__bytes, (base + 76));
\t\t},
\t\tget aSlice(): A[] {
\t\t\treturn __slice32(mem, $A, (base + 80));
\t\t},
\t\tget constASlice(): A[] {
\t\t\treturn __slice32(mem, $A, (base + 88));
\t\t},
\t\tget aPtr(): Pointer<A> {
\t\t\treturn $aPtr || ($aPtr = new Pointer<A>(mem, (base + 96),
\t\t\t(addr) => $A(mem).instance(addr)
\t\t\t));
\t\t},
\t\tget aPtr2(): Pointer<A[]> {
\t\t\treturn $aPtr2 || ($aPtr2 = new Pointer<A[]>(mem, (base + 100),
\t\t\t(addr) => __array(mem, $A, addr, 2)
\t\t\t));
\t\t},
\t\tget aPtrMulti(): number {
\t\t\treturn mem.u32[(base + 104) >>> 2];
\t\t},
\t\tset aPtrMulti(x: number) {
\t\t\tmem.u32[(base + 104) >>> 2] = x;
\t\t},
\t};
});
"
`;

exports[`slices 3`] = `
"const std = @import("std");
const bindgen = @import("wasm-api-bindgen");

pub const U8Slice = bindgen.Slice([]u8, [*]u8);
pub const ConstU8Slice = bindgen.Slice([]const u8, [*]const u8);

pub const ASlice = bindgen.Slice([]A, [*]A);
pub const ConstASlice = bindgen.Slice([]const A, [*]const A);

pub const A = extern struct {
    a: u16,
};

export fn A_align() usize {
    return @alignOf(A);
}

export fn A_size() usize {
    return @sizeOf(A);
}

export fn A_a_align() usize {
    return @alignOf(u16);
}

export fn A_a_offset() usize {
    return @offsetOf(A, "a");
}

export fn A_a_size() usize {
    return @sizeOf(u16);
}

pub const B = extern struct {
    slice: U8Slice,
    constSlice: ConstU8Slice,
    ptr: *u8,
    constPtr: *const u8,
    ptr2: *[2]u8,
    ptr2sentinel: *[2:0]u8,
    constPtr2: *const [2]u8,
    constPtr2sentinel: *const [2:0]u8,
    ptrMulti: [*]u8,
    ptrMultiSentinel: [*:255]u8,
    constPtrMulti: [*]const u8,
    constPtrMultiSentinel: [*:255]const u8,
    array: [2]i32,
    arraySentinel: [2:0]i32,
    aSingle: A,
    aSlice: ASlice,
    constASlice: ConstASlice,
    aPtr: *A,
    aPtr2: *[2]A,
    /// Multiple A's
    aPtrMulti: [*]A,
};

export fn B_align() usize {
    return @alignOf(B);
}

export fn B_size() usize {
    return @sizeOf(B);
}

export fn B_slice_align() usize {
    return @alignOf(U8Slice);
}

export fn B_slice_offset() usize {
    return @offsetOf(B, "slice");
}

export fn B_slice_size() usize {
    return @sizeOf(U8Slice);
}

export fn B_constSlice_align() usize {
    return @alignOf(ConstU8Slice);
}

export fn B_constSlice_offset() usize {
    return @offsetOf(B, "constSlice");
}

export fn B_constSlice_size() usize {
    return @sizeOf(ConstU8Slice);
}

export fn B_ptr_align() usize {
    return @alignOf(*u8);
}

export fn B_ptr_offset() usize {
    return @offsetOf(B, "ptr");
}

export fn B_ptr_size() usize {
    return @sizeOf(*u8);
}

export fn B_constPtr_align() usize {
    return @alignOf(*const u8);
}

export fn B_constPtr_offset() usize {
    return @offsetOf(B, "constPtr");
}

export fn B_constPtr_size() usize {
    return @sizeOf(*const u8);
}

export fn B_ptr2_align() usize {
    return @alignOf(*[2]u8);
}

export fn B_ptr2_offset() usize {
    return @offsetOf(B, "ptr2");
}

export fn B_ptr2_size() usize {
    return @sizeOf(*[2]u8);
}

export fn B_ptr2sentinel_align() usize {
    return @alignOf(*[2:0]u8);
}

export fn B_ptr2sentinel_offset() usize {
    return @offsetOf(B, "ptr2sentinel");
}

export fn B_ptr2sentinel_size() usize {
    return @sizeOf(*[2:0]u8);
}

export fn B_constPtr2_align() usize {
    return @alignOf(*const [2]u8);
}

export fn B_constPtr2_offset() usize {
    return @offsetOf(B, "constPtr2");
}

export fn B_constPtr2_size() usize {
    return @sizeOf(*const [2]u8);
}

export fn B_constPtr2sentinel_align() usize {
    return @alignOf(*const [2:0]u8);
}

export fn B_constPtr2sentinel_offset() usize {
    return @offsetOf(B, "constPtr2sentinel");
}

export fn B_constPtr2sentinel_size() usize {
    return @sizeOf(*const [2:0]u8);
}

export fn B_ptrMulti_align() usize {
    return @alignOf([*]u8);
}

export fn B_ptrMulti_offset() usize {
    return @offsetOf(B, "ptrMulti");
}

export fn B_ptrMulti_size() usize {
    return @sizeOf([*]u8);
}

export fn B_ptrMultiSentinel_align() usize {
    return @alignOf([*:255]u8);
}

export fn B_ptrMultiSentinel_offset() usize {
    return @offsetOf(B, "ptrMultiSentinel");
}

export fn B_ptrMultiSentinel_size() usize {
    return @sizeOf([*:255]u8);
}

export fn B_constPtrMulti_align() usize {
    return @alignOf([*]const u8);
}

export fn B_constPtrMulti_offset() usize {
    return @offsetOf(B, "constPtrMulti");
}

export fn B_constPtrMulti_size() usize {
    return @sizeOf([*]const u8);
}

export fn B_constPtrMultiSentinel_align() usize {
    return @alignOf([*:255]const u8);
}

export fn B_constPtrMultiSentinel_offset() usize {
    return @offsetOf(B, "constPtrMultiSentinel");
}

export fn B_constPtrMultiSentinel_size() usize {
    return @sizeOf([*:255]const u8);
}

export fn B_array_align() usize {
    return @alignOf([2]i32);
}

export fn B_array_offset() usize {
    return @offsetOf(B, "array");
}

export fn B_array_size() usize {
    return @sizeOf([2]i32);
}

export fn B_arraySentinel_align() usize {
    return @alignOf([2:0]i32);
}

export fn B_arraySentinel_offset() usize {
    return @offsetOf(B, "arraySentinel");
}

export fn B_arraySentinel_size() usize {
    return @sizeOf([2:0]i32);
}

export fn B_aSingle_align() usize {
    return @alignOf(A);
}

export fn B_aSingle_offset() usize {
    return @offsetOf(B, "aSingle");
}

export fn B_aSingle_size() usize {
    return @sizeOf(A);
}

export fn B_aSlice_align() usize {
    return @alignOf(ASlice);
}

export fn B_aSlice_offset() usize {
    return @offsetOf(B, "aSlice");
}

export fn B_aSlice_size() usize {
    return @sizeOf(ASlice);
}

export fn B_constASlice_align() usize {
    return @alignOf(ConstASlice);
}

export fn B_constASlice_offset() usize {
    return @offsetOf(B, "constASlice");
}

export fn B_constASlice_size() usize {
    return @sizeOf(ConstASlice);
}

export fn B_aPtr_align() usize {
    return @alignOf(*A);
}

export fn B_aPtr_offset() usize {
    return @offsetOf(B, "aPtr");
}

export fn B_aPtr_size() usize {
    return @sizeOf(*A);
}

export fn B_aPtr2_align() usize {
    return @alignOf(*[2]A);
}

export fn B_aPtr2_offset() usize {
    return @offsetOf(B, "aPtr2");
}

export fn B_aPtr2_size() usize {
    return @sizeOf(*[2]A);
}

export fn B_aPtrMulti_align() usize {
    return @alignOf([*]A);
}

export fn B_aPtrMulti_offset() usize {
    return @offsetOf(B, "aPtrMulti");
}

export fn B_aPtrMulti_size() usize {
    return @sizeOf([*]A);
}
"
`;

exports[`external 1`] = `
"#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <stdalign.h>
#include "wasmapi.h"


typedef struct { Bar* ptr; size_t len; } BarSlice;
typedef struct { const Bar* ptr; size_t len; } ConstBarSlice;

typedef struct WASM_Foo WASM_Foo;

// external type: Bar (size: 18, align: 16)

struct WASM_Foo {
    Bar a;
    Bar* b;
    Bar c[2];
    BarSlice d;
};

size_t __attribute__((used)) WASM_Foo_align() {
    return alignof(WASM_Foo);
}

size_t __attribute__((used)) WASM_Foo_size() {
    return sizeof(WASM_Foo);
}

size_t __attribute__((used)) WASM_Foo_a_align() {
    return alignof(Bar);
}

size_t __attribute__((used)) WASM_Foo_a_offset() {
    return offsetof(WASM_Foo, a);
}

size_t __attribute__((used)) WASM_Foo_a_size() {
    return sizeof(Bar);
}

size_t __attribute__((used)) WASM_Foo_b_align() {
    return alignof(Bar*);
}

size_t __attribute__((used)) WASM_Foo_b_offset() {
    return offsetof(WASM_Foo, b);
}

size_t __attribute__((used)) WASM_Foo_b_size() {
    return sizeof(Bar*);
}

size_t __attribute__((used)) WASM_Foo_c_align() {
    return alignof(Bar[2]);
}

size_t __attribute__((used)) WASM_Foo_c_offset() {
    return offsetof(WASM_Foo, c);
}

size_t __attribute__((used)) WASM_Foo_c_size() {
    return sizeof(Bar[2]);
}

size_t __attribute__((used)) WASM_Foo_d_align() {
    return alignof(BarSlice);
}

size_t __attribute__((used)) WASM_Foo_d_offset() {
    return offsetof(WASM_Foo, d);
}

size_t __attribute__((used)) WASM_Foo_d_size() {
    return sizeof(BarSlice);
}


#ifdef __cplusplus
}
#endif
"
`;

exports[`external 2`] = `
"// @ts-ignore possibly includes unused imports
import { defType, Pointer, WasmStringPtr, type IWasmMemoryAccess, type MemorySlice, type MemoryView, type WasmTypeBase, type WasmTypeKeys } from "@thi.ng/wasm-api";
// @ts-ignore
import { __array, __instanceArray, __slice32, __primslice32 } from "@thi.ng/wasm-api/memory";

// external type: Bar (size: 18, align: 16)

export interface Foo extends WasmTypeBase {
\ta: Bar;
\treadonly b: Pointer<Bar>;
\treadonly c: Bar[];
\treadonly d: Bar[];
}

// @ts-ignore possibly unused args
export const $Foo = defType<Foo>(16, 112, (mem, base) => {
\tlet $b: Pointer<Bar>;
\treturn {
\t\tget a(): Bar {
\t\t\treturn $Bar(mem).instance(base);
\t\t},
\t\tset a(x: Bar) {
\t\t\tmem.u8.set(x.__bytes, base);
\t\t},
\t\tget b(): Pointer<Bar> {
\t\t\treturn $b || ($b = new Pointer<Bar>(mem, (base + 32),
\t\t\t(addr) => $Bar(mem).instance(addr)
\t\t\t));
\t\t},
\t\tget c(): Bar[] {
\t\t\treturn __array(mem, $Bar, (base + 48), 2);
\t\t},
\t\tget d(): Bar[] {
\t\t\treturn __slice32(mem, $Bar, (base + 96));
\t\t},
\t};
});
"
`;

exports[`external 3`] = `
"const std = @import("std");
const bindgen = @import("wasm-api-bindgen");

pub const BarSlice = bindgen.Slice([]Bar, [*]Bar);
pub const ConstBarSlice = bindgen.Slice([]const Bar, [*]const Bar);

// external type: Bar (size: 18, align: 16)

pub const Foo = extern struct {
    a: Bar,
    b: *Bar,
    c: [2]Bar,
    d: BarSlice,
};

export fn Foo_align() usize {
    return @alignOf(Foo);
}

export fn Foo_size() usize {
    return @sizeOf(Foo);
}

export fn Foo_a_align() usize {
    return @alignOf(Bar);
}

export fn Foo_a_offset() usize {
    return @offsetOf(Foo, "a");
}

export fn Foo_a_size() usize {
    return @sizeOf(Bar);
}

export fn Foo_b_align() usize {
    return @alignOf(*Bar);
}

export fn Foo_b_offset() usize {
    return @offsetOf(Foo, "b");
}

export fn Foo_b_size() usize {
    return @sizeOf(*Bar);
}

export fn Foo_c_align() usize {
    return @alignOf([2]Bar);
}

export fn Foo_c_offset() usize {
    return @offsetOf(Foo, "c");
}

export fn Foo_c_size() usize {
    return @sizeOf([2]Bar);
}

export fn Foo_d_align() usize {
    return @alignOf(BarSlice);
}

export fn Foo_d_offset() usize {
    return @offsetOf(Foo, "d");
}

export fn Foo_d_size() usize {
    return @sizeOf(BarSlice);
}
"
`;
